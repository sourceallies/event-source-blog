## Conclusion

Now that we have covered all of the components that make up the *Great Plains Trucking* system, we can talk about some of the benefits of this kind of architecture. The first, and probably greatest, benefit of an event sourced system is isolation. It isolates different business processes from one another. A change to the rules for accepting a shipment do not affect the rules for delivering a shipment or paying an account. This isolation is also reflected in the code. A traditional REST based state mutation system would need to add more rules to the same handlers to determine who can save a record (depends on the state) and what makes a record valid (depends on where it is in the process). This makes it hard to reason about the effects that chaning one process has on the behavior of others. In our system, each handler that is responsible for validating the structure and security of one step in the process is isolated and independent of the others.

While there are libraries and frameworks specific to event sourcing, they are not needed to implement this pattern. Our application uses well tested and familiar frameworks and tools (NodeJS, Hapi, MongoDB). The only specific requirement is the ability to queue messages and procesess them synchronously within each entity. Because of this, event sourcing can be leveraged within existing teams and applications as appropriate.

Most applications, sooner or later, will require some level of auditing and history tracking. Often, this is bolted on later in the form of a database trigger or some audit table that is written to as the application updates data. These solutions often cause the main system to become more complicated as they are shoehorned into an architecture that was not initially designed for it. They also suffer from lack of context: an audit table can track that a user changed a value from "27" to "20" on a particular date, but cannot track why that value changed (e.x. was a payment made, or a refund issued?). Event sourcing naturally tracks these events as the source of truth and leverages this data as an asset to the wider system rather than a burden. This feature is doubly important in systems that have regulatory requirements around auditing like healthcare and financial systems.

We are not here to claim that event sourcing is the best architecture for every project. In fact, it is probably a poor choice the majority of the time. This architecture has more moving pieces than a state mutation based system. This leads to extra complexity if the application never adds enough business process to take advantage of it. A system that allows users to modify data without a prescribed process (i.e. modifying a user profile) doesn't need event sourcing and there would typically only be one type of event "update X".

State is mutated eventually and not directly. It is possible for clients to submit a command and then query up the state of an entity and not see the command applied yet because it is still being processed. It is also possible for a command to be submitted successfully but then be rejected by the command handler because the state of the entity changed while the command was in flight. Clients would need the ability to check on the status of a command or be notified when a command is rejected. Mitigating these shortcomings can result in additional complexity for both the server and clients.


